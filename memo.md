**strtolについて**
`strtol(p, &p, 10))`
数字として解釈できる部分まで読み込んでくれる上に、ポインタを進めてくれる。賢い。標準関数

**文字列について**
>（文字列が'\0'で終わっているのと同じです）
そうなんだ

**グローバル変数のTokenについて**
初期化の中身はどうなっているのかなあ
-> 上部では宣言しているだけ。本体はtokenize()で一番最初のtokenがが返され、それが代入される。

**goto failバグ**
人に話せる

**完成する木構造**
先に処理したノードが最終的に下に来ている感じ。

**パッケージ着るならどうする?**
現在の処理
- main関数
- トークナイズ用の定義, 関数, 補助関数(consume, expectなど)
- トークン列から構文木のパーサ

**バグ？**
適当に中身を見ようと思ったらセグフォになってしまった 一旦見送り
(commit id defa3ef995e40e985774 あたりに適当に追加すれば再現すると思う)
```
token = tokenize(argv[1]);
    Node *tree = expr();
    Token *next = token->next;
    char *val = (&next).str;
```

**復習**
文字列をパースして数字か記号のトークン列にする(連結リスト)
トークン列を解析して木構造にする
木構造を解析してスタックマシンを利用したニーモニックを生成する

BNFで現れる単位と木構造で現れる単位(=node->kind)は微妙に違うものなので(?)マッピングを考えないといけない(?)

**比較演算子の登場**
true, falseという概念はなく、1, 0として扱う

**memcmp**
arg1とarg2が同じなら返り値0
そうでなければ1 or -1
if文のテクニックを使っている。(比較対象が同じかを確かめたいのなら、if文内の式はreturn trueなのでは？と少し戸惑ってしまう)
```
if (memcmp(token->str, op, token->len))){
    return false;
}
```

**作業(不等号などの追加)**
トークンに長さを持たせる。 
トークナイズに不等号などを認識させる
ノード生成(ND_EQUALなどを型に追加する)
genを改造する


